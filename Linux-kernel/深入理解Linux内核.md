# 绪论

## Unix 内核概述

### 进程/内核模式

1. 所有标准的Unix内核只用到了内核态和用户态。用户态执行时，不能直接访问内核数据结构或者内核的程序。 一个程序只有在需要使用内核服务的时候才会切换到内核态。 当内核满足了用户程序请求之后，在切换到用户态下。
2. 注意，内核本身不是一个进程，而是进程的管理者。请求内核服务的进程使用系统调用，填入相应的请求参数，然后执行与硬件相关的CPU指令完成内核态的切换。
3. 进程调用系统调用、外围设备发出中断（每个中断处理信号都是由中断处理程序来处理的）)、内核线程被执行时候

### 内核实现

1. 每个进程都是由进程描述符来表示，这个描述符包含了有关进程**当前状态的信息**

### 可重入内核

1. 注意，所有的Unix内核都是可重入的，也就是说多个进程可以同时在内核态下执行。
2. 提供可重入的方式是编写函数，以便函数只能修改局部变量，不修改全局变量就不会发生数据冲突。
3. 虽然在单处理器系统上只有一个进程在运行，但是很多进程可能处与内核态下等待CPU。

### 进程地址空间

1. 每个进程运行在它的私有地址空间，涉及到私有堆栈、数据区、代码区。内核态运行时，进程访问的是内核的数据区和代码区，但使用另外的私有栈。
2. 每个进程访问一个私有地址空间，但有时进程之间也会共享部分地址空间，从而实现进程之间的通信。System V 引入并且已经被Linux支持的“共享内存"技术。

### 同步和临界区

### 非抢占式内核

1. 多数Unix内核都是非抢占式的，当进程在内核态执行的时候，它不能被随意挂起。内核态的进程能自愿放弃CPU，但是在这种情况下，它必须确保所有的数据结构都处于一种一致性状态。 如果内核支持抢占，应该给予其同步机制。

### 禁止中断

1. 单处理系统上的一种同步机制是，进入临界区之前禁止所有硬件中断，离开的时候再重新启用中断。  因为如果临界区比较大的话，那么这段时间可能硬件都处于冻结状态。
2. 只适用于单处理器系统

### 信号量

1. 单处理器系统和多处理器系统都适用，
2. 可以把信号量看成一个对象，组成：一个整数变量、等待进程的连表、两个成员方法：down()和up()

### 自旋锁

1. 信号量有的时候效率比较低，为了检查信号量，内核必须把进程插入到信号量链表上，然后挂起它，操作比较费时。 自旋锁与信号量相似，但没有进程链表，当一个进程发现锁被另外一个进程锁着的时候，它就不停地“旋转"，执行一个紧凑的循环指令直到锁打开为之。
2. 注意，自旋锁在单处理器环境下是无效的，因为没有机会释放这个锁。

### 信号

1. 信号是一种把系统事件报告给进程的一种机制，每种事件都有自己的编号。
2. POSIX标准自定义了20种不同的信号，其中有2种是用户自定义的。
3. Unix SYstem V 引入了其他种类用户态下进程间通信机制：信号量、消息队列、共享内存。
4. 内核把他们作为一个IPC资源来实现，IPC资源是持久不变的，因为使用完之后需要显式的释放这些资源。

### 进程管理

### 僵尸进程

1. 一个名为init的特殊系统进程，在系统初始化的时候被创建，一个进程终止的时候会改变其所有子进程的进程描述符，这些子进程成为init的孩子，init监控所有子进程的执行。

## 内存管理

### 虚拟内存

1. 现代CPU包含了能自动把虚拟地址转换成物理地址的硬件电路

### 随即访问存储器的

1. 所有的Unix操作系统都将RAM 分成两部分，一部分放 内核，另外一部分用于虚拟内存

### 内核内存分配器

1. 是一个子系统，满足系统中所有对内存的请求。应该尽量满足：快、浪费少、内存碎片小、与其他系统合作。

### 进程虚拟地址空间处理

1. 内核通常有一组内存区描述符描述了进程的虚拟地址空间。虚拟地址空间组成如下：

   > 程序可执行代码、程序初始化数据、程序初始化堆栈、共享库的可执行代码和数据
   >
2. 现代Unix操作系统都采用了所谓的 请求调页的内存分配策略，当访问不存在的页面时，MMU产生异常，然后处理程序分配一个空闲页面，并且用适当的数据对它进行初始化。

注意：当子进程被创建的时候，会沿用父进程的页表，但是只读，如果尝试修该，内核才会分配新的页面。这就大大提高了系统的利用率。


### 高速缓存

### 设备驱动程序

1.内核通过设备驱动程序与I/O设备交互，设备驱动程序包含在内核中，比如键盘、鼠标、摄像头等设备驱动程序。优点如下：

> 特定设备的代码封装在特定模块、厂家只需要知道接口规范、内核通过统一的方式对待所有设备，并且通过相同的接口访问设备
>
> 可以把驱动程序写成模块，从而动态的装进内核。
